#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    pSpeedPot,      sensorPotentiometer)
#pragma config(Sensor, dgtl12, pActivator,     sensorDigitalIn)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           mpTest,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Always open the debug stream window when the program starts
#pragma DebuggerWindows("debugStream")


#include <CKGeneral.h>
#include <CKVex.h>

#define CKAveragerSampleSize 4
#include <CKAverager.h>




const float TicksPerRev = TicksPerRev_393Standard;

const int MaxMotorPower = 127;





struct MotorState {
	int port;
	float power;
	int powerDir;

	float imeRevs;
	float imeVelocity; // revs per second
	float imeAccel; // revs/sec^2

	// Used for calculating velocity
	unsigned long imeTime0;
};

void updateMotorPower( MotorState& self );

void MotorStateInit( MotorState& self, int port ){
	self.port = port;
	self.power = 0;
	self.powerDir = 1;
	self.imeRevs = 0;
	self.imeVelocity = 0;

	self.imeTime0 = nPgmTime;

	nMotorEncoder[ self.port ] = 0;

	updateMotorPower( self );
}

void updateMotorPower( MotorState& self ){
	motor[ self.port ] = (int)round( self.power * MaxMotorPower );
}


void setPower( MotorState& self, float power ){
	self.power = bound( power, -1, 1 );
	updateMotorPower( self );
}

//void nextPower( MotorState& self ){
//	if( fabs(self.power) >= 1.0 ){
//		self.powerDir = -self.powerDir;
//	}
//	self.power += self.powerDir * 0.01;

//	updateMotorPower( self );
//}

void measureVelocity( MotorState& self ){
	unsigned long now = nPgmTime;
	self.imeRevs = nMotorEncoder[ self.port ] / TicksPerRev;
	nMotorEncoder[ self.port ] = 0;

	float dt = (float)(now - self.imeTime0) / 1000.0;
	if( dt == 0 ) dt = 1;
	float velocity0 = self.imeVelocity;
	self.imeVelocity = (float)self.imeRevs / dt;
	self.imeAccel = (self.imeVelocity - velocity0) / dt;

	self.imeTime0 = now;
}


task main(){

	MotorState testMotor;
	MotorStateInit( testMotor, mpTest );

	Averager accelAverager;
	AveragerInit( accelAverager );

	//float v = MainBatteryVoltage();

	while( !isPressed(pActivator) )  delay(10);
	while(  isPressed(pActivator) )  delay(10);

	const unsigned long MinRunTime = 2000;
	unsigned long startTime = nPgmTime;
	setPower( testMotor, 1.0 );
	float avgAccel = 0;
	while( !isPressed(pActivator) ){
		measureVelocity(testMotor);
		addSample( accelAverager, testMotor.imeAccel );
		avgAccel = average( accelAverager );
		//writeDebugStreamLine("%2.2f\t%4d\t%f\t%f", v, testMotor.power, testMotor.imeVelocity, avgAccel);
		writeDebugStreamLine("%f\t%f", testMotor.imeVelocity, avgAccel);
		if( nPgmTime - startTime > MinRunTime && avgAccel < 0 ){
			break;
		}
		wait1Msec(100);
	}

	setPower( testMotor, 0 );
}
