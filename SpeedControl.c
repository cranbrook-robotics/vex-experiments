#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    pSpeedPot,      sensorPotentiometer)
#pragma config(Sensor, dgtl12, pActivator,     sensorDigitalIn)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           mpTest,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Always open the debug stream window when the program starts
#pragma DebuggerWindows("debugStream")


#include <CKGeneral.h>
#include <CKVex.h>

#define CKAveragerSampleSize 20
#include <CKAverager.h>




const float TicksPerRev = TicksPerRev_393Standard;
const float RadiansPerTick = 2*PI/TicksPerRev;

const int MaxMotorPower = 127;





struct MotorState {
	int port;
	float power;

	float imePosition; // radians
	float imeVelocity; // radians per second
	float imeAccel; // radians/sec^2

	// Used for calculating velocity
	long imeTime0;
};

void updateMotorPower( MotorState& self );

void MotorStateInit( MotorState& self, int port ){
	self.port = port;
	self.power = 0;
	self.imePosition = 0;
	self.imeVelocity = 0;

	self.imeTime0 = nPgmTime;

	nMotorEncoder[ self.port ] = 0;

	updateMotorPower( self );
}

void updateMotorPower( MotorState& self ){
	motor[ self.port ] = (int)round( self.power * MaxMotorPower );
}


void setPower( MotorState& self, float power ){
	self.power = bound( power, -1, 1 );
	updateMotorPower( self );
}

void measureVelocity( MotorState& self ){
	long now = nPgmTime;
	float dx = nMotorEncoder[ self.port ] * RadiansPerTick;
	nMotorEncoder[ self.port ] = 0;
	self.imePosition += dx;
	float dt = (float)(now - self.imeTime0) / 1000.0;
	if( dt == 0 ) dt = 1;
	float velocity0 = self.imeVelocity;
	self.imeVelocity = dx / dt;
	self.imeAccel = (self.imeVelocity - velocity0) / dt;

	self.imeTime0 = now;
}


float potentiometer( int port ){
	return SensorValue[port] / 4095.0;
}


void gradualStop( MotorState& self ){
	float s = sgn( self.power );
	for( float p = fabs(self.power); p > 0; p -= 0.01 ){
		setPower( self, s*p );
		delay(80);
	}
	setPower( self, 0 );
}


void waitUntilRest( MotorState& self ){
	//waitUntilMotorStop( self.port );
	int restCount = 0;
	while( restCount < 5 ){
		measureVelocity( self );
		if( self.imeVelocity < 0.001 )
			++restCount;
		else
			restCount = 0;
		delay(50);
	}
}

float powerForVelocity( float v ){
	return 0.101 * exp(0.197 * v);
}

float getVelocityDial(){
	return 9*potentiometer(pSpeedPot);
}


task main(){

	MotorState testMotor;
	MotorStateInit( testMotor, mpTest );

	Averager accelAverager;
	AveragerInit( accelAverager );

	Averager velocityAverager;
	AveragerInit( velocityAverager );

	Averager errorAverager;
	AveragerInit( errorAverager );

	float v = MainBatteryVoltage();

	while( !isPressed(pActivator) )  delay(10);
	while(  isPressed(pActivator) )  delay(10);


	float targetVelocity = getVelocityDial();
	float idealPower = powerForVelocity( targetVelocity );

	float p = 0, error, avgError;

	for( long iTime = nPgmTime; !isPressed(pActivator); iTime = nPgmTime ) {
		targetVelocity = getVelocityDial();
		measureVelocity(testMotor);
		error = testMotor.imeVelocity - targetVelocity;
		addSample( errorAverager, error );
		avgError = average( errorAverager );
		p = 0.1 * error + 0.1 * avgError;
		setPower(testMotor, idealPower - p);


		writeDebugStreamLine("%.2f\t%.3f\t%.3f\t%.3f", v, testMotor.power, testMotor.imeVelocity, targetVelocity);

		while( nPgmTime - iTime < 50 )delay(2);
	}

	gradualStop( testMotor );
}
