#pragma config(UserModel, "C:/Users/rstudent/code/robot-configs/35.c")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Always open the debug stream window when the program starts
#pragma DebuggerWindows("debugStream")


#include <CKFlywheelSpeedController.h>






task main(){
	FlywheelSpeedController leftFly, rightFly;


	const int MotorsPerFlywheel = 3;
	tMotor LFlyPorts[MotorsPerFlywheel] = { mFlyL1, mFlyL2, mFlyL3 };
	tMotor RFlyPorts[MotorsPerFlywheel] = { mFlyR1, mFlyR2, mFlyR3 };

	// Standard internal gearbox (aka torque) is the default, so you don't need to pass that
	// in if you're using standard.
	FlywheelSpeedControllerInit( leftFly, LFlyPorts, MotorsPerFlywheel, M393Standard );
	FlywheelSpeedControllerInit( rightFly, RFlyPorts, MotorsPerFlywheel, M393Standard );

	// Got the IMEs attached to the upper motor of each flywheel.
	setMotorPortOfIME( leftFly, mFlyL3 );
	setMotorPortOfIME( rightFly, mFlyR3 );

	setFlywheelBatteryConfig( leftFly, vPowerExpander, 0.33 );
	setFlywheelBatteryConfig( rightFly, NoPort, 1 );




	MovingAverage maAccelerationL, maAccelerationR;
	MovingAverageInit( maAccelerationL, 8 );
	MovingAverageInit( maAccelerationR, 8 );

	MovingAverage maVelocityL, maVelocityR;
	MovingAverageInit( maVelocityL, 8 );
	MovingAverageInit( maVelocityR, 8 );



	const long MinRunTime = 2000;


			//setPower( leftFly, 1 );
			//setPower( rightFly, 1 );
			//while(1);

	for( int rep = 0; rep < 1; ++rep ){
		for( float po = 0.3; po <= 1.001; po += 0.1 ){
			setPower( leftFly, po );
			setPower( rightFly, po );

			long startTime = nPgmTime;
			float avgAccel = 0;
			float vSumL = 0, vSumR = 0;
			int vCount = 0;
			int cruising = 0;

			while( true ){
				long iTime = nPgmTime;
				vSumL += flywheelBatteryVoltage(leftFly);
				vSumR += flywheelBatteryVoltage(rightFly);
				++vCount;
				measure( leftFly );
				measure( rightFly );
				nextSample( maVelocityL, getMeasuredSpeed(leftFly) );
				nextSample( maVelocityR, getMeasuredSpeed(rightFly) );
				nextSample( maAccelerationL, getMeasuredAcceleration(leftFly) );
				nextSample( maAccelerationR, getMeasuredAcceleration(rightFly) );

				// Only used to tell when to stop
				avgAccel = ( getAverage(maAccelerationL) + getAverage(maAccelerationR) ) / 2.0;

				if( nPgmTime - startTime > MinRunTime ){
					if( !cruising ){
						if( avgAccel < 0 ){
							cruising = 1;
						}
					} else if( ++cruising > 30 ){
						break; // cruise for 3 seconds after reaching 0ish acceleration.
					}
				}

				long iterationDuration = nPgmTime - iTime;
				delay( 100 - iterationDuration );
			}

			float vL = vSumL / vCount, vR = vSumR / vCount;
			writeDebugStreamLine( "%.2f\t%.2f\t%.2f\t%.2f\t%.2f", po, vL, vR, getAverage(maVelocityL), getAverage(maVelocityR) );

			setPower( leftFly, 0 );
			setPower( rightFly, 0 );
			waitUntilRest( leftFly.flywheelMotors );
			waitUntilRest( rightFly.flywheelMotors );
		}
	}
}
